# ADR-050: Interaction Event Schema

- **Status:** ✅ Decidido
- **Date:** 27-feb-2026
- **Deciders:** PO (Sergio), Arquitecto AICE
- **Related:** ADR-049 (Server-Side Scoring)

## Decisión

El cliente envía eventos de interacción clasificados. El hub calcula el scoring. El cliente NUNCA envía deltas, scores ni streaks.

## Schema del evento

### Lo que el cliente ENVÍA

```json
{
  "side": "agent",                    // "agent" | "user"
  "eventType": "error",              // "error" | "correct" | "pro_pattern" | "anti_pattern" | "bonus" | "exceptional"
  "domain": "TECH",                  // TECH | OPS | JUDGMENT | COMMS | ORCH
  "severity": "medio",              // solo para errors: leve | medio | grave | critico
  "patternCode": "HALLUCINATION",   // código del patrón (opcional)
  "quadrant": "AGENT_PROBLEM",      // GOOD | AGENT_COMPENSATED | AGENT_PROBLEM | COMMS_BREAKDOWN (opcional)
  "trigger": "auto-score",          // qué trigger activó: puntúa | auto-score | task-complete | idea-validate
  "clusterRef": "evt-uuid-prev",    // referencia al evento raíz si es derivado de cluster (opcional)
  "sessionId": "session-123",       // para detectar reincidencia intra-sesión
  "timestamp": "2026-02-27T10:15:00Z"
}
```

### Lo que el cliente NO envía

| Campo | Por qué no |
|-------|-----------|
| `delta` | Lo calcula el servidor |
| `scoreAfter` | Lo calcula el servidor |
| `streak` | Estado interno del servidor |
| `evalCount` | Lo mantiene el servidor |
| Contenido de la conversación | Privacidad absoluta |
| Hash del contenido | Privacidad (descartado en v1) |

### Lo que el servidor DEVUELVE

```json
{
  "eventId": "uuid",
  "accepted": true,
  "scoring": {
    "delta": -3,
    "domainScoreAfter": 27.0,
    "globalScoreAfter": 34.2,
    "streakAfter": 0,
    "evalCount": 28,
    "wasReincidence": false,
    "wasCluster": false,
    "capApplied": false
  },
  "state": {
    "agent": {
      "global": 34.2,
      "domains": {
        "TECH": { "score": 27, "streak": 0 },
        "OPS": { "score": 13, "streak": 0 },
        "JUDGMENT": { "score": 45, "streak": 0 },
        "COMMS": { "score": 15, "streak": 0 },
        "ORCH": { "score": 51, "streak": 0 }
      }
    },
    "user": {
      "global": 42.0,
      "domains": { "..." : "..." }
    },
    "team": 36.2,
    "maturity": { "tier": "GREEN", "evalCount": 28 }
  }
}
```

El estado completo se devuelve en cada respuesta. El cliente lo cachea localmente.

## Contexto

### ¿Por qué no enviar contenido?
Privacidad absoluta. El hub no necesita saber QUÉ se dijo — solo necesita la clasificación del evento. La clasificación la hace el agente (o el usuario cuando dice "puntúa").

### ¿Quién clasifica?
El agente clasifica automáticamente (triggers auto-score, task-complete, idea-validate). El usuario clasifica explícitamente (trigger puntúa). El hub confía en la clasificación pero aplica reglas anti-gaming:
- Rate limits previenen spam de eventos positivos
- Reincidencia detectada por sessionId + patternCode
- Anomalías estadísticas detectadas por distribución

### ¿Cómo maneja clusters el servidor?
El cliente envía `clusterRef` apuntando al evento raíz. El servidor aplica la regla: raíz 100%, derivados 50%. Si el cliente no marca cluster, el servidor trata cada evento como independiente.

## Consecuencias

- El protocolo es simple: clasificar + enviar + recibir score
- El cliente no necesita implementar lógica de scoring
- La privacidad se mantiene: zero contenido, zero hashes
- El servidor tiene toda la información para calcular correctamente
